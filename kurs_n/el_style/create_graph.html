<html dir="ltr" lang="ru">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">
</head>

<body>
    <div class="container page-wrap" style="width: 640; height: 420;">
        <div class="content">
            <section id="canvasSection">
                <canvas id="canvas" width="640" height="420">Ваш браузер не поддерживается. Попробуйте обновить ваш браузер до последней версии.</canvas>
            </section>
        </div>
    </div>
    <script type="text/javascript">
        /**
         *  Place here all tests constans.
         *
         */
        var g_processing, g_graphOfMinDist, g_selectStartVertexForShortPath, g_checkToSave, g_showDistMatrix;

        function Point(x, y){
            this.x = x || 0;
            this.y = y || 0;
        };
        Point.prototype.x = null;
        Point.prototype.y = null;
        Point.prototype.add = function(v){
            return new Point(this.x + v.x, this.y + v.y);
        };
        Point.prototype.addValue = function(v){
            return new Point(this.x + v, this.y + v);
        };
        Point.prototype.clone = function(){
            return new Point(this.x, this.y);
        };
        Point.prototype.degreesTo = function(v){
            var dx = this.x - v.x;
            var dy = this.y - v.y;
            var angle = Math.atan2(dy, dx); // radians
            return angle * (180 / Math.PI); // degrees
        };
        Point.prototype.distance = function(v){
            return Math.sqrt(this.distanceSqr(v));
        };
        Point.prototype.distanceSqr = function(v){
            var x = this.x - v.x;
            var y = this.y - v.y;
            return x * x + y * y;
        };
        Point.prototype.equals = function(toCompare){
            return this.x == toCompare.x && this.y == toCompare.y;
        };
        Point.prototype.interpolate = function(v, f){
            return new Point((this.x + v.x) * f, (this.y + v.y) * f);
        };
        Point.prototype.length = function(){
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
        Point.prototype.normalize = function(thickness){
            var l = this.length();
            this.x = this.x / l * thickness;
            this.y = this.y / l * thickness;
            return new Point(this.x, this.y);
        };
        Point.prototype.normalizeCopy = function(thickness){
            var l = this.length();
            return new Point(this.x / l * thickness, this.y / l * thickness);
        };
        Point.prototype.orbit = function(origin, arcWidth, arcHeight, degrees){
            var radians = degrees * (Math.PI / 180);
            this.x = origin.x + arcWidth * Math.cos(radians);
            this.y = origin.y + arcHeight * Math.sin(radians);
        };
        Point.prototype.rotate = function(center, degrees){
            var radians = degrees * (Math.PI / 180);
            offset = this.subtract(center);
            this.x = offset.x * Math.cos(radians) - offset.y * Math.sin(radians);
            this.y = offset.x * Math.sin(radians) + offset.y * Math.cos(radians);
            this.x = this.x + center.x;
            this.y = this.y + center.y;
        };

        Point.prototype.offset = function(dx, dy){
            this.x += dx;
            this.y += dy;
        };
        Point.prototype.subtract = function(v){
            return new Point(this.x - v.x, this.y - v.y);
        };
        Point.prototype.subtractValue = function(value){
            return new Point(this.x - value, this.y - value);
        };
        Point.prototype.multiply = function(value){
            return new Point(this.x * value, this.y * value);
        };
        Point.prototype.toString = function(){
            return "(x=" + this.x + ", y=" + this.y + ")";
        };

        Point.prototype.normal = function(){
            return new Point(-this.y, this.x);
        };

        Point.prototype.min = function(point)
        {
            return new Point(Math.min(this.x, point.x), Math.min(this.y, point.y));
        };

        Point.prototype.max = function(point)
        {
            return new Point(Math.max(this.x, point.x), Math.max(this.y, point.y));
        };

        Point.prototype.inverse = function()
        {
            return new Point(-this.x, -this.y);
        };
         
        Point.interpolate = function(pt1, pt2, f){
            return new Point(pt1.x * (1.0 - f) + pt2.x * f, pt1.y * (1.0 - f) + pt2.y * f);
        };
        Point.polar = function(len, angle){
            return new Point(len * Math.cos(angle), len * Math.sin(angle));
        };
        Point.distance = function(pt1, pt2){
            var x = pt1.x - pt2.x;
            var y = pt1.y - pt2.y;
            return Math.sqrt(x * x + y * y);
        };

        Point.center = function(pt1, pt2){
            return new Point((pt1.x + pt2.x) / 2.0, (pt1.y + pt2.y) / 2.0);
        };

        Point.toString = function(){
            return x + " " + y;
        }

        function Rect(minPoint, maxPoint){
            this.minPoint = minPoint;
            this.maxPoint = maxPoint;
        };

        Rect.prototype.center = function()
        {
            return Point.center(this.minPoint, this.maxPoint);
        };

        Rect.prototype.size = function()
        {
            return this.maxPoint.subtract(this.minPoint);
        };
        /**
         * This is edge model
         *
         */

        function EdgeModel()
        {
            this.width = 4;
        }
        /**
         * This is graph model used for hit test and draw.
         *
         */


        function VertexModel()
        {
            this.diameter = 30;
        }
        /**
         * Base node class.
         *
         */

         
        function BaseVertex(x, y, vertexEnumType)
        {
            this.position = new Point(x, y);
            this.id       = 0;
            this.mainText = "";
            this.upText   = "";
            this.vertexEnumType = vertexEnumType;
            this.model    = new VertexModel();
        };

        BaseVertex.prototype.position = new Point(0, 0);



        BaseVertex.prototype.SetId = function (id)
        {
            this.id       = id;
            this.mainText = this.vertexEnumType.GetVertexText(id);                       
        }

        BaseVertex.prototype.diameterFactor = function ()
        {
            return 1.0 + (this.mainText.length ? this.mainText.length / 8.0 : 0);
        }
        /**
         * This is base arc.
         *
         *
         */

        function BaseEdge(vertex1, vertex2, isDirect, weight, useWeight)
        {
            this.vertex1    = vertex1;
            this.vertex2    = vertex2;
            this.isDirect  = isDirect;
            this.weight    = Number(weight);
            // For direct graph, has pair edge or not.
            this.hasPair   = false;
            this.useWeight = useWeight;
            this.id        = 0;
            this.model = new EdgeModel();
        }





        BaseEdge.prototype.GetPixelLength = function ()
        {
            if (this.vertex1 == this.vertex2)
            {
                return (new CommonEdgeStyle()).sizeOfLoop * 2 * Math.PI;
            }
            else
            {
                return Point.distance(this.vertex1.position, this.vertex2.position);
            }
        }

        BaseEdge.prototype.GetWeight = function ()
        {
            return this.useWeight ? this.weight : 1;
        }/**
         * Graph drawer.
         */
         
        // Common style of Graphs.
        function CommonVertexStyle()
        {
          this.lineWidth   = 1;
          this.strokeStyle = '#c7b7c7';
          this.fillStyle   = '#68aeba';
          this.mainTextColor = '#f0d543';
        }

        // Selected style of Graphs.
        function SelectedVertexStyle0()
        {
            CommonVertexStyle.apply(this, arguments);
            this.strokeStyle = '#f0d543';
            this.mainTextColor  = '#f0d543';
            this.fillStyle   = '#c7627a';
        }

        SelectedVertexStyle0.prototype = Object.create(CommonVertexStyle.prototype);

        function SelectedVertexStyle1()
        {
            CommonVertexStyle.apply(this, arguments);
            this.strokeStyle = '#7a9ba0';
            this.mainTextColor  = '#7a9ba0';
            this.fillStyle   = '#534641';
        }

        SelectedVertexStyle1.prototype = Object.create(CommonVertexStyle.prototype);

        function SelectedVertexStyle2()
        {
            CommonVertexStyle.apply(this, arguments);
            this.strokeStyle = '#8C4C86';
            this.mainTextColor  = '#8C4C86';
            this.fillStyle   = '#253267';
        }

        SelectedVertexStyle2.prototype = Object.create(CommonVertexStyle.prototype);

        function SelectedVertexStyle3()
        {
            CommonVertexStyle.apply(this, arguments);
            this.strokeStyle = '#6188FF';
            this.mainTextColor  = '#6188FF';
            this.fillStyle   = '#E97CF9';
        }

        SelectedVertexStyle3.prototype = Object.create(CommonVertexStyle.prototype);

        function SelectedVertexStyle4()
        {
            CommonVertexStyle.apply(this, arguments);
            this.strokeStyle = '#C6B484';
            this.mainTextColor  = '#C6B484';
            this.fillStyle   = '#E0DEE1';
        }

        SelectedVertexStyle4.prototype = Object.create(CommonVertexStyle.prototype);

        var selectedGraphStyles = [new SelectedVertexStyle0(), new SelectedVertexStyle1(),
            new SelectedVertexStyle2(), new SelectedVertexStyle3(), new SelectedVertexStyle4()];
                           
        function BaseVertexDrawer(context)
        { 
          this.context = context;
        }

        BaseVertexDrawer.prototype.Draw = function(baseGraph, graphStyle)
        {
          this.SetupStyle(graphStyle);
          this.DrawShape(baseGraph);
          this.context.stroke();
          this.context.fill();
          this.DrawCenterText(baseGraph.position, baseGraph.mainText, graphStyle.mainTextColor, graphStyle.fillStyle, true, true, 16);
          this.DrawCenterText(baseGraph.position.add(new Point(0, - baseGraph.model.diameter / 2.0 - 9.0)), 
            baseGraph.upText, graphStyle.fillStyle, graphStyle.strokeStyle, false, false, 12.0);
        }

        BaseVertexDrawer.prototype.SetupStyle = function(style)
        {
          this.context.lineWidth   = style.lineWidth;
          this.context.strokeStyle = style.strokeStyle;
          this.context.fillStyle   = style.fillStyle;
        }

        BaseVertexDrawer.prototype.DrawShape = function(baseGraph)
        {
          this.context.lineWidth    = 2;
          this.context.beginPath();
          this.context.arc(baseGraph.position.x, baseGraph.position.y, baseGraph.model.diameter / 2.0, 0, 2 * Math.PI);
          this.context.closePath();
        }

        BaseVertexDrawer.prototype.DrawText = function(position, text, color, outlineColor, outline, font)
        {
            this.context.fillStyle = color;
            this.context.font = font;
            this.context.lineWidth = 4;
            this.context.strokeStyle = outlineColor;

            if (outline)
            {
                this.context.save();
                this.context.lineJoin = 'round';
                this.context.strokeText(text, position.x, position.y);
                this.context.restore();
            }
            
            this.context.fillText(text, position.x, position.y);
        }

        BaseVertexDrawer.prototype.DrawCenterText = function(position, text, color, outlineColor, bold, outline, size)
        {
            this.context.textBaseline="middle";
            this.context.font = (bold ? "bold " : "") + size + "px sans-serif";
            var textWidth  = this.context.measureText(text).width;  
            this.DrawText(new Point(position.x - textWidth / 2, position.y), text, color, outlineColor, outline, this.context.font);
        }

        /**
         * Graph drawer.
         */
         
         
        function CommonEdgeStyle()
        {
            this.strokeStyle = '#c7b7c7';
            this.weightText  = '#f0d543';
            this.fillStyle   = '#68aeba';
            this.textPadding = 4;
            this.textStrockeWidth = 2;
            this.sizeOfLoop = 24;
            this.loopShiftAngel = Math.PI / 6;
        }


        function SelectedEdgeStyle0()
        {
            CommonEdgeStyle.apply(this, arguments);  
            this.strokeStyle = '#f0d543';
            this.weightText  = '#f0d543';
            this.fillStyle   = '#c7627a';
        }
        SelectedEdgeStyle0.prototype = Object.create(CommonEdgeStyle.prototype);

        function ProgressEdgeStyle()
        {
            CommonEdgeStyle.apply(this, arguments);
            var selectedStyle = new SelectedEdgeStyle0();
            this.strokeStyle = selectedStyle.fillStyle;
            this.weightText  = '#000000';
            this.fillStyle   = '#000000';
        }
        ProgressEdgeStyle.prototype = Object.create(CommonEdgeStyle.prototype);

        function SelectedEdgeStyle1()
        {
            CommonEdgeStyle.apply(this, arguments);  
            this.strokeStyle = '#8FBF83';
            this.weightText  = '#8FBF83';
            this.fillStyle   = '#F9F9D5';
        }
        SelectedEdgeStyle1.prototype = Object.create(CommonEdgeStyle.prototype);


        function SelectedEdgeStyle2()
        {
            CommonEdgeStyle.apply(this, arguments);  
            this.strokeStyle = '#8C4C86';
            this.weightText  = '#8C4C86';
            this.fillStyle   = '#253267';
        }
        SelectedEdgeStyle2.prototype = Object.create(CommonEdgeStyle.prototype);


        function SelectedEdgeStyle3()
        {
            CommonEdgeStyle.apply(this, arguments);  
            this.strokeStyle = '#6188FF';
            this.weightText  = '#6188FF';
            this.fillStyle   = '#E97CF9';
        }
        SelectedEdgeStyle3.prototype = Object.create(CommonEdgeStyle.prototype);


        function SelectedEdgeStyle4()
        {
            CommonEdgeStyle.apply(this, arguments);  

            this.strokeStyle = '#C6B484';
            this.weightText  = '#C6B484';
            this.fillStyle   = '#E0DEE1';
        }
        SelectedEdgeStyle4.prototype = Object.create(CommonEdgeStyle.prototype);

        var selectedEdgeStyles = [new SelectedEdgeStyle0(), new SelectedEdgeStyle1(), 
            new SelectedEdgeStyle2(), new SelectedEdgeStyle3(), new SelectedEdgeStyle4()];


        function BaseEdgeDrawer(context)
        { 
          this.context = context;
        }

        BaseEdgeDrawer.prototype.Draw = function(baseEdge, arcStyle) 
        {
          this.SetupStyle(baseEdge, arcStyle);

          var positions = this.GetArcPositions(baseEdge.vertex1.position, baseEdge.vertex2.position, baseEdge.vertex1.model.diameter);
          
          this.DrawArc (positions[0], positions[1], arcStyle);
          if (baseEdge.useWeight)
          {
            this.DrawWeight(positions[0], positions[1], baseEdge.weight, arcStyle, baseEdge.hasPair);
          }
        }


        BaseEdgeDrawer.prototype.SetupStyle = function(baseEdge, arcStyle)
        {
          this.context.lineWidth   = baseEdge.model.width;
          this.context.strokeStyle = arcStyle.strokeStyle;
          this.context.fillStyle   = arcStyle.fillStyle;
          this.sizeOfLoop          = baseEdge.vertex1.model.diameter / 2;
        }

        BaseEdgeDrawer.prototype.DrawArc = function(position1, position2, arcStyle)
        {
          if (position1.equals(position2))
          {
            this.context.beginPath();
            this.context.arc(position1.x - Math.cos(arcStyle.loopShiftAngel) * arcStyle.sizeOfLoop, 
                             position1.y - Math.sin(arcStyle.loopShiftAngel) * arcStyle.sizeOfLoop, arcStyle.sizeOfLoop, 0, 2 * Math.PI);
            this.context.closePath();
            this.context.stroke();
          }
          else
          {
            this.context.beginPath();
            this.context.moveTo(position1.x, position1.y);
            this.context.lineTo(position2.x, position2.y);
            this.context.closePath();
            this.context.stroke();  
          }
        }

        BaseEdgeDrawer.prototype.DrawWeight = function(position1, position2, text, arcStyle, hasPair)
        { 
          var textShift  = Math.min(12 / position1.subtract(position2).length(), 0.4);
          var centerPoint = Point.interpolate(position1, position2, 0.5 + (hasPair ? textShift : 0));
          if (position1.equals(position2))
          {
            centerPoint.y = centerPoint.y - Math.cos(arcStyle.loopShiftAngel) * arcStyle.sizeOfLoop * 2;
            centerPoint.x = centerPoint.x - Math.sin(arcStyle.loopShiftAngel) * arcStyle.sizeOfLoop * 2;
          }
          this.context.font         = "bold 16px sans-serif";
          this.context.textBaseline = "middle";
          this.context.lineWidth    = arcStyle.textStrockeWidth;
          this.context.fillStyle    = arcStyle.fillStyle;   

          var widthText = this.context.measureText(text).width;

          this.context.beginPath();
          this.context.rect(centerPoint.x - widthText / 2 - arcStyle.textPadding / 2, 
                            centerPoint.y - 8 - arcStyle.textPadding / 2, 
            widthText + arcStyle.textPadding, 16 + arcStyle.textPadding);
          this.context.closePath();
          this.context.fill();
          this.context.stroke ();

            this.context.fillStyle = arcStyle.weightText;   
            this.context.fillText(text, centerPoint.x - widthText / 2, centerPoint.y);
        }

        BaseEdgeDrawer.prototype.GetArcPositions = function(position1, position2, diameter1, diameter2)
        {
          var direction = position1.subtract(position2); 
          direction.normalize(1.0);
          direction = direction.multiply(0.5);
          
          var res = [];
          res.push(position1.subtract(direction.multiply(diameter1)));
          res.push(position2.subtract(direction.multiply(-diameter2)));
          return res;
        }

        BaseEdgeDrawer.prototype.GetArcPositionsShift = function(position1, position2, diameter1, diameter2, shift)
        {
            if (shift == 0)
            {
                return this.GetArcPositions(position1, position2, diameter1, diameter2);
            }
            else
            {
                var direction = position1.subtract(position2);
                direction.normalize(1.0);
                var normal = direction.normal();
                direction = direction.multiply(0.5);
                position1 = position1.subtract(normal.multiply(shift));
                position2 = position2.subtract(normal.multiply(shift));
                diameter1 = Math.sqrt(diameter1 * diameter1 - shift * shift);
                diameter2 = Math.sqrt(diameter2 * diameter2 - shift * shift);
                var res = [];
                res.push(position1.subtract(direction.multiply(diameter1)));
                res.push(position2.subtract(direction.multiply(-diameter2)));
                return res;
            }  
        }


        /**
         * Direct Arc drawer.
         */
        function DirectArcDrawer(context)
        { 
          this.context = context;
        }

        DirectArcDrawer.prototype = Object.create(BaseEdgeDrawer.prototype);

        DirectArcDrawer.prototype.Draw = function(baseEdge, arcStyle) 
        {
          baseDrawer = this.CreateBase();
          baseDrawer.SetupStyle(baseEdge, arcStyle);
          
          var length = baseEdge.model.width * 4;
          var width  = baseEdge.model.width * 2;
          var position1 = baseEdge.vertex1.position;
          var position2 = baseEdge.vertex2.position;
          var direction = position1.subtract(position2); 
          var pairShift = baseEdge.vertex1.model.diameter * 0.25;
          var realShift = (baseEdge.hasPair ? pairShift : 0);
          direction.normalize(1.0);
          var positions = this.GetArcPositionsShift(baseEdge.vertex1.position,
            baseEdge.vertex2.position, baseEdge.vertex1.model.diameter, baseEdge.vertex2.model.diameter, realShift);
          
          baseDrawer.DrawArc (positions[0], positions[1].subtract(direction.multiply(-length / 2)), arcStyle);

          this.context.fillStyle = this.context.strokeStyle;
          this.context.lineWidth   = 0;
          this.DrawArrow(positions[0], positions[1], length, width);

          if (baseEdge.useWeight)
          {
            baseDrawer.DrawWeight(positions[0], positions[1], baseEdge.weight, arcStyle, baseEdge.hasPair);
          } 
        }

        DirectArcDrawer.prototype.DrawArrow = function(position1, position2, length, width) 
        {
          var direction = position2.subtract(position1); 
          direction.normalize(1.0);
          var normal = direction.normal();
          
          var pointOnLine = position2.subtract(direction.multiply(length));
          var point1 = pointOnLine.add(normal.multiply(width));
          var point2 = pointOnLine.add(normal.multiply(-width));
          
          this.context.beginPath();
          this.context.moveTo(position2.x, position2.y);
          this.context.lineTo(point1.x, point1.y);
          this.context.lineTo(point2.x, point2.y);
          this.context.lineTo(position2.x, position2.y);
          this.context.closePath();
          this.context.fill();
        }

        DirectArcDrawer.prototype.CreateBase = function() 
        {
            return new BaseEdgeDrawer(this.context);
        }





        // Global array of all algorithms.
        var g_Algorithms   = [];
        var g_AlgorithmIds = [];

        // Call this function to register your factory algoritm.
        function RegisterAlgorithm (factory)
        {
            g_Algorithms.push(factory);
            g_AlgorithmIds.push(factory(null).getId());
        }

        // Base algorithm class.
        function BaseAlgorithm (graph, app)
        {
            this.graph = graph;
            this.app = app;
        }

        // calls when user select vertex.
        // @return true if you allow to select this object or false.
        BaseAlgorithm.prototype.selectVertex = function(vertex)
        {
            return false;
        }

        // calls when user select edge.
        // @return true if you allow to select this object or false.
        BaseAlgorithm.prototype.selectEdge = function(edge)
        {
            return false;
        }

        // user click to workspace.
        // @return true if you allow to deselect all
        BaseAlgorithm.prototype.deselectAll = function()
        {
            return true;
        }

        // get result of algorithm.
        // If result if not ready, please return null.
        // It will be called after each user action.
        // Please return true, if you done.
        BaseAlgorithm.prototype.result = function(resultCallback)
        {
            return null;
        }

        // If you no need to get feedback from user, return true.
        // In this case result will calls once.
        BaseAlgorithm.prototype.instance = function()
        {
            return true;
        }

        // @return false, if you change up text and do not want to restore it back.
        BaseAlgorithm.prototype.needRestoreUpText = function()
        {
            return true;
        }

        // @return true, if you change resotry graph after use.
        BaseAlgorithm.prototype.wantRestore = function()
        {
            return false;
        }


        // @return 0, if object is not selected, in other case return groupe of selection.
        BaseAlgorithm.prototype.getObjectSelectedGroup = function(object)
        {
            return 0;
        }


        // Algorithm priority in menu
        BaseAlgorithm.prototype.getPriority = function()
        {
            return 0;
        }



        /**
         * Default handler.
         * Select using mouse, drag.
         *
         */
        function BaseAlgorithmEx(graph, app)
        {
            BaseAlgorithm.apply(this, arguments);
        }


        /** 
         * Base Handler.
         *
         */
         
        function BaseHandler(app)
        {
            this.app = app;
            this.app.setRenderPath([]);
        }

        BaseHandler.prototype.GetSelectedGroup = function(object) 
        {
            return 0;
        }

        /**
         * Add Graph handler.
         *
         */
        function AddGraphHandler(app)
        {
          BaseHandler.apply(this, arguments);   
        }

        // inheritance.
        AddGraphHandler.prototype = Object.create(BaseHandler.prototype);

        AddGraphHandler.prototype.MouseDown = function(pos) 
        {
            this.app.CreateNewGraph(pos.x, pos.y);
            this.needRedraw = true;
            this.inited = false;
        }

        AddGraphHandler.prototype.InitControls = function() 
        {
            var enumVertexsText = document.getElementById("enumVertexsText");
            if (enumVertexsText)
            {
                var enumsList = this.app.GetEnumVertexsList();
                for (var i = 0; i < enumsList.length; i ++)
                {
                    var option = document.createElement('option');
                    option.text  = enumsList[i]["text"];
                    option.value = enumsList[i]["value"];
                    enumVertexsText.add(option, i);
                    if (enumsList[i]["select"])
                    {
                        enumVertexsText.selectedIndex = i;
                    }
                }
                
                var addGraphHandler = this;
                enumVertexsText.onchange = function () {
                    addGraphHandler.ChangedType();
                };
            }
        }

        AddGraphHandler.prototype.ChangedType = function() 
        {
            var enumVertexsText = document.getElementById("enumVertexsText");

            this.app.SetEnumVertexsType(enumVertexsText.options[enumVertexsText.selectedIndex].value);
        }


        /**
         * Graph class.
         *
         */

         
        function Graph()
        {
            // List of vertex.
            this.vertices = [];
            // List of arcs.
            this.edges   = [];
            // Unique Id of new graph.
            this.uidGraph = 0;
            // Unique Id of new edge.
            this.uidEdge = 10000;
            // Has direction edge.
            this.hasDirect = false;
        };


        Graph.prototype.AddNewVertex = function(vertex)
        {
            if (this.vertices.length < 300)
            {
                vertex.SetId (this.uidGraph);
                this.uidGraph = this.uidGraph + 1;
                this.vertices.push(vertex);
            }
            return this.vertices.length - 1;
        }

        Graph.prototype.AddNewEdgeSafe = function(graph1, graph2, isDirect, weight)
        {
            var useWeight = false;
            if (!isNaN(parseInt(weight, 10)))
            {
                useWeight = true;
            }
            weight = (!isNaN(parseInt(weight, 10)) && weight >= 0) ? weight : 1;
            return this.AddNewEdge(new BaseEdge(graph1, graph2, isDirect, weight, useWeight, 0));
        }

        Application.prototype.DeleteEdge = function(edgeObject)
		{
			this.graph.DeleteEdge(edgeObject);
		}

		Application.prototype.DeleteVertex = function(graphObject)
		{
			this.graph.DeleteVertex(graphObject);
		}

		Application.prototype.DeleteObject = function(object)
		{
			if (object instanceof BaseVertex)
			{
				this.DeleteVertex(object);
			}
			else if (object instanceof BaseEdge)
			{
				this.DeleteEdge(object);
			}
		}
		Graph.prototype.DeleteEdge = function(edgeObject)
		{
			var index = this.edges.indexOf(edgeObject);
			if (index > -1) 
			{
				var edgeRevert = this.FindEdge(edgeObject.vertex2, edgeObject.vertex1);
				if (edgeRevert != null && edgeRevert.isDirect)
				{
					edgeRevert.isPair = false;
				}
				this.edges.splice(index, 1);
			}
		}

		Graph.prototype.DeleteVertex = function(vertexObject)
		{
			var index = this.vertices.indexOf(vertexObject);
			if (index > -1) 
			{
				for (var i = 0; i < this.edges.length; i++)
				{
					if (this.edges[i].vertex1 == vertexObject || this.edges[i].vertex2 == vertexObject)
					{
						this.DeleteEdge(this.edges[i]);
						i--;
					}
				}
				this.vertices.splice(index, 1);
			}
		}

        Graph.prototype.AddNewEdge = function(edge)
        {
            edge.id = this.uidEdge;
            this.uidEdge = this.uidEdge + 1;
            
            var edge1      = this.FindEdge(edge.vertex1.id, edge.vertex2.id);
            var edgeRevert = this.FindEdge(edge.vertex2.id, edge.vertex1.id);
            if (!edge.isDirect)
            {
                if (edge1 != null)
                {
                    this.DeleteEdge(edge1);
                }
                if (edgeRevert != null)
                {
                    this.DeleteEdge(edgeRevert);
                }
                this.edges.push(edge);
            }
            else
            {
                if (edge1 != null)
                {
                    this.DeleteEdge(edge1);
                }
                if (edgeRevert != null && !edgeRevert.isDirect)
                {
                    this.DeleteEdge(edgeRevert);
                }
                else if (edgeRevert != null)        
                {
                    edgeRevert.hasPair = true;
                    edge.hasPair = true;
                }
                
                this.edges.push(edge);
            }
            
            return this.edges.length - 1;
        }




        Graph.prototype.FindVertex = function(id)
        {
            var res = null;
            for (var i = 0; i < this.vertices.length; i++)
            {
                if (this.vertices[i].id == id)
                {
                    res = this.vertices[i];
                    break;
                }
            }
            
            return res;
        }

        Graph.prototype.FindEdge = function(id1, id2)
        {
            var res = null;
            for (var i = 0; i < this.edges.length; i++)
            {
                if ((this.edges[i].vertex1.id == id1 && this.edges[i].vertex2.id == id2)
                     || (!this.edges[i].isDirect && this.edges[i].vertex1.id == id2 && this.edges[i].vertex2.id == id1))
                {
                    res = this.edges[i];
                    break;
                }
            }
            
            return res;
        }

        Graph.prototype.GetAdjacencyMatrix = function ()
        {
            var matrix = "";
            for (var i = 0; i < this.vertices.length; i++)
            {
                for (var j = 0; j < this.vertices.length; j++)
                {   
                    var edge = this.FindEdge (this.vertices[i].id, this.vertices[j].id);
                    if (edge != null)
                    {
                        matrix += edge.weight;
                    }
                    else
                    {
                        matrix += "0";
                    }
                    
                    if (j != this.vertices.length)
                    {
                        matrix += ", ";
                    }
                    
                }
                matrix = matrix + "\n";
            }
            
            return matrix;
        }

        Graph.prototype.TestAdjacencyMatrix = function (matrix, rowsObj, colsObj, separator = ",")
        {
            var bGoodFormat = true;
            rowsObj.rows = [];
            rowsObj.rows = matrix.split ("\n");
            for (j = 0; j < rowsObj.rows.length; ++j)
            {
                //rowsObj.rows[j] = rowsObj.rows[j].replace(/ /g,'');
                if (rowsObj.rows[j] === "")
                {
                    rowsObj.rows.splice(j--, 1);
                }
            }
            
            colsObj.cols = [];
            for (var i = 0; i < rowsObj.rows.length; i++)
            {
                colsObj.cols[i] = this.SplitMatrixString(rowsObj.rows[i], separator);//rowsObj.rows[i].split (",");
                for (j = 0; j < colsObj.cols[i].length; ++j)
                {
                    if (colsObj.cols[i][j] === "")
                    {
                        colsObj.cols[i].splice(j--, 1);
                    }
                }
                if (colsObj.cols[i].length != rowsObj.rows.length)
                {
                    bGoodFormat = false;
                    break;
                }
            }

            return bGoodFormat;
        }


        Graph.prototype.IsVertexesHasSamePosition = function (position, vertexCount)
        {
            var res = false;

            for (var j = 0; j < Math.min(this.vertices.length, vertexCount); j++)
            {
                if (position.distance(this.vertices[j].position) < this.vertices[j].model.diameter * 2)
                {
                    res = true;
                    break;
                }
            }

            return res;
        }

        Graph.prototype.GetRandomPositionOfVertex = function (matrix, vertexIndex, viewportSize)
        {
            var point = new Point(0, 0);

            var relatedVertex = [];

            for (var j = 0; j < matrix.length; j++)
            {
                if (j < this.vertices.length && (cols[vertexIndex][j] > 0 || cols[j][vertexIndex] > 0) && j != vertexIndex)
                {
                    relatedVertex.push(this.vertices[j]);
                }
            }


            var diameter = (new VertexModel()).diameter;

            if (relatedVertex.length > 1)
            {
                for (var j = 0; j < relatedVertex.length; j++)
                {
                    point = point.add(relatedVertex[j].position);
                }

                point = point.multiply(1 / relatedVertex.length);

                point.offset (Math.random() * diameter + (Math.random() ? -1 : 1) * 2 * diameter, Math.random() * diameter + (Math.random() ? -1 : 1) * 2 * diameter);
            }
            else
            {
                point = new Point(Math.random() * viewportSize.x, Math.random() * viewportSize.y);
            }

            if (this.IsVertexesHasSamePosition (point, matrix.length))
            { 
                point.offset (Math.random() * diameter + + (Math.random() ? -1 : 1) * 4 * diameter, 
                    Math.random() * diameter + + (Math.random() ? -1 : 1) * 4 * diameter);
            }

            // Clamp
            point.x = Math.min(Math.max(point.x, diameter), viewportSize.x);
            point.y = Math.min(Math.max(point.y, diameter), viewportSize.y);

            return point;
        }

        Graph.prototype.VertexesReposition = function (viewportSize, newVertexes)
        {
           var maxGravityDistanceSqr = Math.max(viewportSize.x, viewportSize.y) / 5.0;
           maxGravityDistanceSqr  = maxGravityDistanceSqr * maxGravityDistanceSqr;
           //Math.min(viewportSize.x, viewportSize.y) / 2.0;
           var velocityDamping    = 0.85;
           var diameter = (new VertexModel()).diameter;
           var maxDistance = diameter * 3;
           var gravityDistanceSqr =  10  * (maxDistance * maxDistance);
           var edgeGravityKof     =  10  / (maxDistance);
           var kCenterForce       =  10  / (maxDistance * 10);
           var centerPoint = viewportSize.multiply(0.5);
           var velocityMax = maxDistance * 10;
            
           var edgesMatrix = {};   
           for (var i = 0; i < this.edges.length; i++)
           {  
                edgesMatrix[this.edges[i].vertex1.id + this.edges[i].vertex2.id * 1000] = 1;
                edgesMatrix[this.edges[i].vertex2.id + this.edges[i].vertex1.id * 1000] = 1;
           }
           
           var startAngel = Math.random() * 180.0;
           for(i = 0; i < newVertexes.length; i++) // loop through vertices
           {
              newVertexes[i].position.orbit(new Point(viewportSize.x / 2, viewportSize.y / 2), (viewportSize.x - diameter * 2) / 2, 
                            (viewportSize.y - diameter * 2) / 2, 360 * i / newVertexes.length + startAngel);
           }
            
           var k = 0;
           var bChanged = true;
           while (k < 1000 && bChanged)
           {
              var vertexData = [];
              for(i = 0; i < newVertexes.length; i++) // loop through vertices
              {
                 // Has no in newVertexes.
                 var currentVertex = {};
                 currentVertex.object    = newVertexes[i];
                 currentVertex.net_force = new Point (0, 0);
                 currentVertex.velocity   = new Point (0, 0);
                 vertexData.push(currentVertex);

                 for(j = 0; j < this.vertices.length; j++) // loop through other vertices
                 {
                    otherVertex = this.vertices[j];
              
                    if (otherVertex == currentVertex.object) continue;
                     
                    // squared distance between "u" and "v" in 2D space
                    var rsq = currentVertex.object.position.distanceSqr(otherVertex.position);
                    
                    
                    {
                      // counting the repulsion between two vertices
                      var force = (currentVertex.object.position.subtract(otherVertex.position)).normalize(gravityDistanceSqr / rsq);
                      currentVertex.net_force = currentVertex.net_force.add(force);
                    }
                 }

                 for(j = 0; j < this.vertices.length; j++) // loop through edges
                 {
                    otherVertex = this.vertices[j];
                    if (edgesMatrix.hasOwnProperty(currentVertex.object.id + 1000 * otherVertex.id))
                    {
                        var distance = currentVertex.object.position.distance(otherVertex.position);
                        
                        if (distance > maxDistance)
                        {
                            // countin the attraction
                            var force = (otherVertex.position.subtract(currentVertex.object.position)).normalize(edgeGravityKof * (distance - maxDistance));
                            currentVertex.net_force = currentVertex.net_force.add(force);
                        }
                    }
                 }
                  
                 // Calculate force to center of world.
                 var distanceToCenter = centerPoint.distance(currentVertex.object.position);
                 var force = centerPoint.subtract(currentVertex.object.position).normalize(distanceToCenter * kCenterForce);
                 currentVertex.net_force = currentVertex.net_force.add(force);
                  
                 // counting the velocity (with damping 0.85)
                 currentVertex.velocity = currentVertex.velocity.add(currentVertex.net_force);
             }

             bChanged = false;

             for(i = 0; i < vertexData.length; i++) // set new positions
             {
                var v = vertexData[i];
                var velocity = v.velocity;
                if (velocity.length() > velocityMax)
                {
                    velocity = velocity.normalize(velocityMax);
                }
                v.object.position = v.object.position.add(velocity);
                if (velocity.length() >= 1)
                {
                  bChanged = true;
                }
             }
             k++;
           }
            
            
           // Looks like somthing going wrong and will use circle algorithm for reposition.
           var bbox = this.getGraphBBox();
           if (bbox.size().length() > viewportSize.length() * 1000)
           {
               for(i = 0; i < newVertexes.length; i++) // loop through vertices
               {
                   newVertexes[i].position.orbit(new Point(viewportSize.x / 2, viewportSize.y / 2), (viewportSize.x - diameter * 2) / 2,
                                                 (viewportSize.y - diameter * 2) / 2, 360 * i / newVertexes.length + startAngel);
               }
           }
           else
           {
               // Try to rotate graph to fill small area.
               var count = 10;
               var agnle  = 360.0 / count;
               var viewportAspect = viewportSize.x / viewportSize.y;
               var bestIndex = 0;
               var graphSize  = bbox.size();
               var bestAspect = graphSize.x / graphSize.y;
               var center     = bbox.center();
               
               for (var i = 1; i < count; i++)
               {
                   for(j = 0; j < newVertexes.length; j++) // loop through vertices
                   {
                       newVertexes[j].position.rotate(center, agnle);
                   }
                   
                   var newBBox   = this.getGraphBBox();
                   var newAspect = newBBox.size().x / newBBox.size().y;
                   if (Math.abs(newAspect - viewportAspect) < Math.abs(bestAspect - viewportAspect))
                   {
                       bestAspect = newAspect;
                       bestIndex = i;
                   }
               }
               
               // Rotate to best aspect.
               for(j = 0; j < newVertexes.length; j++) // loop through vertices
               {
                   newVertexes[j].position.rotate(center, - agnle * (count - bestIndex - 1));
               }
           }
        }



        Graph.prototype.SetAdjacencyMatrix = function (matrix, viewportSize, currentEnumVertesType, separator = ",")
        {
            var rowsObj = {};
            var colsObj = {};

            //ViewportSize = viewportSize.subtract(new Point((new VertexModel()).diameter * 2, (new VertexModel()).diameter * 2));

            if (this.TestAdjacencyMatrix(matrix, rowsObj, colsObj, separator))
            {
                rows = rowsObj.rows;
                cols = colsObj.cols;
                for (var i = 0; i < this.edges.length; i++)
                {
                    this.DeleteEdge (this.edges[i]);
                }
                
                var newVertexes = [];
                var bWeightGraph = false;
                
                for (var i = 0; i < rows.length; i++)
                {
                    for (var j = 0; j < rows.length; j++)
                    {
                        if (j >= this.vertices.length)
                        {
                            var newPos = this.GetRandomPositionOfVertex (matrix, j, viewportSize);
                            newVertexes.push(new BaseVertex(newPos.x, newPos.y, currentEnumVertesType));
                            this.AddNewVertex(newVertexes[newVertexes.length - 1]);
                        }
                        
                        if (cols[i][j] > 0)
                        {
                            var nEdgeIndex = this.AddNewEdgeSafe(this.vertices[i], this.vertices[j], cols[i][j] != cols[j][i], cols[i][j]);
                            if (nEdgeIndex >= 0)
                            {
                                bWeightGraph = bWeightGraph || this.edges[nEdgeIndex].weight != 1;
                            }
                        }
                    }
                }
                
                // Set use weight false, because we have unwieghts graph.
                if (!bWeightGraph)
                {
                    this.edges.forEach(function(part, index, theArray) {
                                       theArray[index].useWeight = false;
                                       });
                }

                for (var i = rows.length; i < Math.max(this.vertices.length, rows.length); i++)
                {
                    this.DeleteVertex(this.vertices[i]);
                    i--;
                }                        

                this.VertexesReposition(viewportSize, newVertexes);
            }   
        }

        Graph.prototype.SplitMatrixString = function (line, separator = ",")
        {
          var res = [];
          var i = 0;

          // For case: 00110101101
          var isZeroOneLine = true;

          for (i = 0; i < line.length; i++)
          {
            if (line.charAt(i) != '0' && line.charAt(i) != '1')
            {
              isZeroOneLine = false;
              break;
            }
          } 

          if (!isZeroOneLine)
          {
            if (separator != ",")
            {
                line = line.replace(/,/g, ".");
            }
            for (i = 0; i < line.length; i++)
            {
              // add , if we use space as separator
              if (("0123456789.-e").indexOf(line.charAt(i)) < 0 )
              {
                if (i > 0)
                { 
                  res.push(line.substr(0, i));
                }
                if (i == 0) 
                {
                  i = 1;
                }
                line = line.substr(i, line.length - i);
                i = -1;
              }
            }
            if (line.length > 0)
            {
              res.push(line);
            }
          }
          else
          {
            for (i = 0; i < line.length; i++)
            {
              res.push(line.charAt(i));
            }
          }

          console.log(res);
          return res;
        }




        Graph.prototype.hasDirectEdge = function ()
        {
            var res = false;
            for (var i = 0; i < this.edges.length; i++)
            {
                if(this.edges[i].isDirect)
                {
                    res = true;
                    break;
                }
            }
            
            return res;
        }

        Graph.prototype.clampPositions = function (viewportSize)
        {
            var diameter = (new VertexModel()).diameter;

                for(i = 0; i < this.vertices.length; i++) // set new positions
                {
                    this.vertices[i].position.x = Math.min(Math.max(this.vertices[i].position.x, diameter), viewportSize.x - diameter);
                    this.vertices[i].position.y = Math.min(Math.max(this.vertices[i].position.y, diameter), viewportSize.y - diameter);
                }
        }

        // Use to setup scaling.
        Graph.prototype.getGraphBBox = function (viewportSize)
        {
            var pointMin = new Point(1e5, 1e5);
            var pointMax = new Point(-1e5, -1e5);
            var diameter = (new VertexModel()).diameter;
            
            for(i = 0; i < this.vertices.length; i++)
            {
                var vertex = this.vertices[i];
                var deltaVector = new Point(vertex.diameterFactor() * diameter, diameter);
                pointMin = pointMin.min(vertex.position.subtract(deltaVector));
                pointMax = pointMax.max(vertex.position.add(deltaVector));
            }
            
            return new Rect(pointMin, pointMax);
        }
        /*
          Classes for create text for vertexs.
        */


        /**
         * Base Enum Vertexs.
         *
         */ 
        function BaseEnumVertices(app)
        {
            this.app = app;
        }

        BaseEnumVertices.prototype.GetVertexText = function(id)
        {
            return id;
        }




        /**
         * Text Enum
         *
         */
        function TextEnumVertexs(app)
        {
            BaseEnumVertices.apply(this, arguments);
            this.pattern = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        }

        /**
         * Text Enum
         *
         */
        function TextEnumVertexsCyr(app)
        {
            TextEnumVertexs.apply(this, arguments);
            this.pattern = "ааааааааааааааааа аЁаЂаЃаЄаЅаІаЇаЈаЉаЊаЋаЌа­аЎаЏ";
        }




        /**
         * Text Enum
         *
         */
        function TextEnumVertexsGreek(app)
        {
            TextEnumVertexs.apply(this, arguments);
            this.pattern = "ЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮЮ ЮЁЮЃЮЄЮЅЮІЮЇЮЈЮЉ";
        }


        // inheritance.
        TextEnumVertexsGreek.prototype = Object.create(TextEnumVertexs.prototype);

        TextEnumVertexsGreek.prototype.GetText = function()
        {
            return "Ю, Ю, ... ЮЉ";
        }

        TextEnumVertexsGreek.prototype.GetValue = function()
        {
            return "Greek";
        }

        /**
         * Text Enum
         *
         */
        function TextEnumVertexsCustom(app)
        {
            BaseEnumVertices.apply(this, arguments);
            this.pattern = "";
        }





        /**
         * This is main application class.
         *
         */
         
        var globalApplication = null;
         
        function Application(document, window)
        {
            this.document = document;
            this.canvas  = this.document.getElementById('canvas');
            this.handler = new AddGraphHandler(this);
            this.savedGraphName = "";
            this.currentEnumVertesType = new BaseEnumVertices(this);//this.enumVertexesTextList[0];
            this.findPathReport = 1;
            this.isTimerRender = false;
            globalApplication  = this;
            this.renderPath = [];
            this.renderTimer = 0;
            this.renderPathLength  = 0;
            this.renderPathCounter = 0;
            this.renderPathLoops = 0;
            this.enumVertexesTextList = [new BaseEnumVertices(this), new TextEnumVertexs(this), new TextEnumVertexsCyr(this), new TextEnumVertexsGreek(this), new TextEnumVertexsCustom(this)];
            this.SetDefaultTransformations();
            this.algorithmsValues = {};
            this.userAction = function(){};
        };

        // List of graph.
        //Application.prototype.graph.vertices     = [];
        // Current draged object.
        Application.prototype.graph = new Graph();
        Application.prototype.dragObject = -1;
        // List of graph.edges.
        //Application.prototype.graph.edges       = [];
        // User handler.
        Application.prototype.handler = null;
        // Hold status.
        Application.prototype.status = {};
        // Graph name length
        Application.prototype.graphNameLength = 16;


        Application.prototype.getMousePos = function(canvas, e)
        {
            /// getBoundingClientRect is supported in most browsers and gives you
            /// the absolute geometry of an element
            var rect = canvas.getBoundingClientRect();

            /// as mouse event coords are relative to document you need to
            /// subtract the element's left and top position:
            return {x: (e.clientX - rect.left) / this.canvasScale - this.canvasPosition.x, y: (e.clientY - rect.top) / this.canvasScale - this.canvasPosition.y};
        }

        Application.prototype.redrawGraph = function()
        {
            if (!this.isTimerRender)
            {
                this._redrawGraph();
            }
        }

        Application.prototype.redrawGraphTimer = function()
        {
            if (this.isTimerRender)
            {
                var context = this._redrawGraph();
                
                // Render path
                if (this.renderPath.length > 1)
                {
                    context.save();
                    context.scale(this.canvasScale, this.canvasScale);
                    context.translate(this.canvasPosition.x, this.canvasPosition.y);
                    
                    var movePixelStep = 16;
                    var currentLength = 0;
                    
                    var i = 0
                    for (i = 0; i < this.renderPath.length - 1; i++)
                    {
                        var edge = this.graph.FindEdge(this.renderPath[i], this.renderPath[i + 1]);
                        currentLength += edge.GetPixelLength();
                        if (currentLength > this.renderPathCounter)
                        {
                            currentLength -= edge.GetPixelLength();
                            break;
                        }
                    }
                    
                    if (i >= this.renderPath.length - 1)
                    {
                        i = 0;
                        this.renderPathCounter = 0;
                        currentLength = 0;
                        this.renderPathLoops += 1;
                    }
                    
                    var edge = this.graph.FindEdge(this.renderPath[i], this.renderPath[i + 1]);
                    
                    var progress = (this.renderPathCounter - currentLength) / edge.GetPixelLength();
                    
                    this.RedrawEdgeProgress(context, edge, edge.vertex1.id == this.renderPath[i] ? progress : 1.0 - progress);

                    this.renderPathCounter += movePixelStep;
                    
                    context.restore();
                }
            }
            
            if (this.renderPathLoops >= 5)
            {
                this.stopRenderTimer();
            }
        }

        Application.prototype._redrawGraph = function()
        {
            var context = this.canvas.getContext('2d');
            
            context.save();
            context.clearRect(0, 0, Math.max(this.canvas.width, this.GetRealWidth()), Math.max(this.canvas.height, this.GetRealHeight()));
            context.scale(this.canvasScale, this.canvasScale);
            context.translate(this.canvasPosition.x, this.canvasPosition.y);
            
            this.RedrawEdges(context);
            this.RedrawNodes(context);
            
            context.restore();
            
            return context;
        }

        Application.prototype._OffscreenRedrawGraph = function()
        {
            var bbox = this.graph.getGraphBBox();
            var canvas = document.createElement('canvas');
            canvas.width  = bbox.size().x;
            canvas.height = bbox.size().y;
            var context = canvas.getContext('2d');
            
            context.save();
            context.clearRect(0, 0, Math.max(this.canvas.width, this.GetRealWidth()), Math.max(this.canvas.height, this.GetRealHeight()));
            context.translate(bbox.minPoint.inverse().x, bbox.minPoint.inverse().y);
            
            this.RedrawEdges(context);
            this.RedrawNodes(context);
            
            context.restore();
            
            return canvas;
        }

        Application.prototype.updateRenderPathLength = function()
        {
            this.renderPathLength = 0;
            this.renderPathCounter = 0;
            if (this.renderPath.length > 1)
            {
                for (var i = 0; i < this.renderPath.length - 1; i++)
                {
                    var edge = this.graph.FindEdge(this.renderPath[i], this.renderPath[i + 1]);
                    this.renderPathLength += edge.GetPixelLength();
                }
            }
        }

        Application.prototype.startRenderTimer = function()
        {
            this.updateRenderPathLength();
            this.renderTimer = window.setInterval(function(){globalApplication.redrawGraphTimer();}, 50);
            this.isTimerRender = true;
            this.renderPathLoops = 0;
        }

        Application.prototype.stopRenderTimer = function()
        {
            if (this.isTimerRender)
            {
                window.clearInterval(this.renderTimer);
                this.isTimerRender = false;
                this.renderPathLoops = 0;
            }
        }

        Application.prototype.setRenderPath = function(renderPath)
        {
            this.renderPath = renderPath;
            
            if (this.renderPath.length > 0)
            {
                this.startRenderTimer();
            }
            else
            {
                this.stopRenderTimer();
            }
        }

        Application.prototype.RedrawEdge = function(context, edge)
        {
            var arcDrawer = new BaseEdgeDrawer(context);
            var directArcDrawer  = new DirectArcDrawer(context);
            var commonStyle      = new CommonEdgeStyle(context);
            var selectedStyles   = selectedEdgeStyles;
            
            this._RedrawEdge(edge, arcDrawer, directArcDrawer, commonStyle, selectedStyles);
        }

        Application.prototype._RedrawEdge = function(edge, arcDrawer, directArcDrawer, commonStyle, selectedStyles)
        {
            var selectedGroup = this.handler.GetSelectedGroup(edge);
            var currentStyle  = selectedGroup > 0 ?
                selectedStyles[(selectedGroup - 1) % selectedStyles.length] : commonStyle;
            
            this._RedrawEdgeWithStyle(edge, currentStyle, arcDrawer, directArcDrawer, commonStyle, selectedStyles);
        }

        Application.prototype._RedrawEdgeWithStyle = function(edge, style, arcDrawer, directArcDrawer, commonStyle, selectedStyles)
        {
            if (!edge.isDirect)
            {
                arcDrawer.Draw(edge, style);
            }
            else
            {
                directArcDrawer.Draw(edge, style);
            }
        }



        Application.prototype.RedrawEdges = function(context)
        {
            for (i = 0; i < this.graph.edges.length; i ++)
            {
                this.RedrawEdge(context, this.graph.edges[i]);
            }
        }


        Application.prototype.RedrawNodes = function(context)
        {
            var graphDrawer = new BaseVertexDrawer(context);
            var commonGraphDrawer = new CommonVertexStyle();
            var selectedGraphDrawer = selectedGraphStyles;

            for (i = 0; i < this.graph.vertices.length; i ++)
            {
                var selectedGroup = this.handler.GetSelectedGroup(this.graph.vertices[i]);
                var currentStyle  = selectedGroup > 0 ?
                        selectedGraphDrawer[(selectedGroup - 1) % selectedGraphDrawer.length] : commonGraphDrawer;

                //this.graph.vertices[i].upText = this.handler.GetUpText(this.graph.vertices[i]);

                graphDrawer.Draw(this.graph.vertices[i], currentStyle);
            }   
        }


        Application.prototype.onLoad = function()
        {
            this.canvas = this.document.getElementById('canvas');
            this.handler = new AddGraphHandler(this);
            this.redrawGraph();
        }

        Application.prototype.GetAdjacencyMatrix = function ()
        {
            return this.graph.GetAdjacencyMatrix();
        }

        Application.prototype.SetAdjacencyMatrix = function (matrix, separator = ",")
        {
            this.graph.SetAdjacencyMatrix(matrix, new Point(this.GetRealWidth(), this.GetRealHeight()), this.currentEnumVertesType, separator);
            this.AutoAdjustViewport();
            this.redrawGraph();
            return true;
        }
                             
        Application.prototype.GetRealWidth = function ()
        {
            return this.canvas.width / this.canvasScale;
        }
                                  
        Application.prototype.GetRealHeight = function ()
        {
            return this.canvas.height / this.canvasScale;
        }
                                  
        Application.prototype.SetDefaultTransformations = function()
        {
            this.canvasScale = 1.0;
            this.canvasPosition = new Point(0, 0);
        }

        Application.prototype.AutoAdjustViewport = function()
        {
            graphBBox  = this.graph.getGraphBBox();
            bboxCenter = graphBBox.center();
            bboxSize   = graphBBox.size();
                                  
            if (bboxSize.length() > 0)
            {
                if (bboxSize.x > this.GetRealWidth() || bboxSize.y > this.GetRealHeight())
                {
                    this.canvasScale = Math.min(this.GetRealWidth() / bboxSize.x, this.GetRealHeight() / bboxSize.y);
                }
                if (graphBBox.minPoint.x < 0.0 || graphBBox.minPoint.y < 0.0 ||
                    graphBBox.maxPoint.x > this.GetRealWidth() || graphBBox.maxPoint.y > this.GetRealHeight())
                {
                    this.canvasPosition  = graphBBox.minPoint.inverse();
                }
            }
        }
        var application = new Application(document, window);
        application.onLoad();
    </script>
</body>
</html>